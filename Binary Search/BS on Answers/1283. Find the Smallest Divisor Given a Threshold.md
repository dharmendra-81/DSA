Given an array of integers `nums` and an integer `threshold`, we will choose a positive integer `divisor`, divide all the array by it, and sum the division's result. Find the **smallest** `divisor` such that the result mentioned above is less than or equal to `threshold`.

Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: `7/3 = 3` and `10/2 = 5`).

The test cases are generated soÂ that there will be an answer

---
#### Brute Force: O(max(arr[]) * N)
```cpp
int smallestDivisor(vector<int>& arr, int limit) {
    int n = arr.size(); 
    int maxi = *max_element(arr.begin(), arr.end());
    for (int d = 1; d <= maxi; d++) {
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += ceil((double)(arr[i]) / (double)(d));
        }
        if (sum <= limit)
            return d;
    }
    return -1;
}
```

#### Optimal
```cpp
class Solution {
public:
    // Helper function: returns the sum of ceil(v[i] / d) for all i
    int sumByD(vector<int>& v, int d) {
        int sum = 0;
        for (int i = 0; i < v.size(); ++i) {
            sum += (v[i] + d - 1) / d;  // Equivalent to ceil(v[i]/d)
        }
        return sum;
    }

    int smallestDivisor(vector<int>& nums, int threshold) {
        int low = 1, high = *max_element(nums.begin(), nums.end());
        int ans = high;

        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (sumByD(nums, mid) <= threshold) {
                ans = mid;         // Possible answer, try smaller divisor
                high = mid - 1;
            } else {
                low = mid + 1;     // Too much sum, try bigger divisor
            }
        }
        return ans;
    }
};
```
