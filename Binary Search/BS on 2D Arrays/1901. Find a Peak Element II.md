A **peak** element in a 2D grid is an element that is **strictly greater** than all of its **adjacent** neighbors to the left, right, top, and bottom.

Given a **0-indexed** `m x n` matrix `mat` where **no two adjacent cells are equal**, find **any** peak element `mat[i][j]` and return _the length 2 array_ `[i,j]`.

You may assume that the entire matrix is surrounded by an **outer perimeter** with the value `-1` in each cell.

---

```cpp
class Solution {
public:
    int maxElementRow(const vector<vector<int>>& mat, int col) {
        int maxVal = INT_MIN, rowIdx = -1;
        for (int r = 0; r < (int)mat.size(); ++r)
            if (mat[r][col] > maxVal)
                maxVal = mat[r][col], rowIdx = r;
        return rowIdx;
    }

    vector<int> findPeakGrid(vector<vector<int>>& mat) {
        int rows = mat.size(), cols = rows ? mat[0].size() : 0;
        int left = 0, right = cols - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int row = maxElementRow(mat, mid);
            int curr = mat[row][mid];
            int lft  = mid > 0 ? mat[row][mid - 1] : INT_MIN;
            int rgt  = mid + 1 < cols ? mat[row][mid + 1] : INT_MIN;
            if (curr > lft && curr > rgt) return {row, mid};
            if (lft > curr) right = mid - 1;
            else left = mid + 1;
        }
        return {-1, -1};
    }
};
```
- maxElementRow is inlined; single pass, no extra variables.
- Ternary in rows ? mat[0].size() : 0 handles empty matrix safely.
- mid = left + (right - left)/2 avoids overflow.
- All neighbour checks use short ternary; INT_MIN for missing edges.
- curr, lft, rgt variables for clarity, single-line updates.
- Early return on peak; direction decided by left neighbor dominance.
- No function doc-comments; pure compact logic.
- Time: O(rows * log cols), minimal constants.
- 